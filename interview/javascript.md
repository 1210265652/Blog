# 数据类型
- js数据类型分类和判断
- 值类型和引用类型
- 引用类型和原型类型的区别
- 函数参数是对象会有什么问题

六种基本数据类型，undefined、null、boolean、string、number、以及ES6新增的symbol，也叫做原始类型，它们存储的都是值，没有函数方法可以调用。其中需要注意的是：
1. number类型是浮点类型，比如 `0.1 + 0.2 !== 0.3`     
2. string一旦创建，它的值就不能改变，要改变某个变量存储的字符串，首先就要销毁原来的字符串，然后再用包含一个新值的字符串填充该变量
3. null虽然使用typeof类型检测输出为 `object` ，但它不是对象类型，它表示一个空对象指针

一种引用类型object，一组无序数据和功能的集合。与原始类型不同的是，原始类型存储的是值，而引用类型存储的是地址（指针）。当创建了一个引用类型时，计算机会在内存中开辟一处空间存放值，引用类型便存放的是这一处空间的地址。对于变量的赋值，也只是将存储地址进行了复制。对于函数的传参，传递的也是对象指针的副本，函数内部如果有对象参数属性的修改会被同步，而引用对象参数值，重新分配地址后的返回对象则不会影响到函数参数。
# 类型判断
- typeof 是否能够正确判断类型
- instanceof 能正确判断对象类型的原理是什么

typeof 对于原始类型来说，除了 `null` 输出object外都可以显示正确的类型；对于对象来说，除了函数都会输出object，所以 typeof 并不能准确的判断变量到底是什么类型。

如果想要判断一个对象的正确类型，可以考虑使用 instanceof，其内部实现是通过原型链来判断的。
# js内置函数有哪些
String、Number、Boolean、Object、Function、Array、Date、RegExp、Error、Symbol
# null 和 undefined的区别
null表示没有对象，它的值为空；undefined表示一个变量声明了但是没有赋值。
- undefined和null在if语句中都会被自动转为false
- typeof null的输出为object而undefined是undefined
- undefined不是一个有效的json，而null是，可以序列化输出。
# == 和 === 的区别
`==` 是抽象相等运算符，在进行了必要的类型转换后在比较值是否相等。

`===` 是严格相等运算符，不会进行类型转换，类型不等直接返回false，类型相同值相同返回true 
### 类型转换注意点：
1. 如果两边都是原始类型，除去特殊值null、undefined和NaN，两者都转为数值进行比较
2. 特殊值在和不包括自身的任何值比较，都为false。其中null和undefined为true，分别与自身也为true，NaN与自身为false
3. 一方为object时，先将object转为原始类型，再进行比较
4. 引用类型之间的比较是在比较内存地址
> `[] == ![]` 本质上是原始类型和引用类型的比较，一元运算符 ! 优先级高于二元运算符 == ，实际判断时表达式已转换为 [] == false，然后将 == 导致的隐式转换，二者都转为数值型比较，0 == 0 为true

# 原型
- 如何理解原型
- 如何理解原型链
- _proto_、 prototype、 construct

每个js对象在创建的时候都会关联另一个对象，这个对象就是原型对象。每一个对象都会从原型继承属性和方法。每个对象都有 `_proto_` 属性，这个属性指向它的原型对象，通过 `_proto_` 将对象和原型对象连接起来组成了原型链。

Object 是所有对象的原型，所有对象通过 `_proto_` 可以找到它

Function 是所有函数的原型，所有函数可以通过 `_proto_` 找到它


# 作用域和闭包
- 执行上下文
- this
- js的作用域和作用域链
- 什么是闭包
- 经典面试题，循环中使用闭包解决 `var` 定义函数的问题

要说闭包首先要从执行上下文说起
### **执行上下文**
浏览器在执行一段js代码之前会先行创建一个**全局执行上下文**环境，将代码中即将执行的变量、函数声明都拿出来，变量暂时赋值为undefined、函数则先声明好可以使用。这一步完成以后再开始正式执行程序。

一个函数执行之前也会创建一个**函数执行上下文**环境，和**全局执行上下文**差不多，不过**函数执行上下文**中会多了`this`、 `arguments`和函数的参数。
### **this**
this是执行上下文环境中的一部分，在代码执行中：
- 作为构造函数执行，this指向实例对象
- 作为对象属性，this指向调用对象
- 作为普通函数执行，this指向window对象
- 箭头函数中的this，取决于包裹箭头函数的第一个普通函数的this
- bind、call、apply方法中的this指向第一个参数，如果参数为空，则指向window
### **作用域**
作用域就是一个独立的地盘，让变量不会外泄、暴露出去。在ES6之前，作用域分全局作用域和函数作用域。使用var定义变量存在变量提升，因此ES6增加了let声明变量，用来创建块级作用域。
### **作用域链**
代码执行过程中，遇到当前作用域没有定义的变量，便会向父级作用域寻找，如果父级也没有，再一层层向上寻找直到全局作用域。这种一层层的关系就是作用域链。
### **闭包**
函数通过作用域链可以访问到另一个函数中的变量，那么这个函数就是闭包。

在js中，闭包存在的意义就是让我们可以间接访问函数作用域内的变量。其主要有两个应用场景：
1. 函数作用返回值
2. 函数作为参数传递

# 异步编程
- 并发和并行的区别
- 什么是回调函数？有什么特点，如何解决回调地狱问题
- Generator
- Promise
- Async和Await
- 常用定时器函数

js是单线程运行的，即在同一时间内只能做一件事，不能“一心二用”。简单区别下并发与并行，并发是指同一时间间隔发生的任务，并行是同时发生。
### **回调函数（callback）**
回调函数是一段可执行的代码，它作为参数传入其他函数在需要时方便调用这段代码。它的特点是：
1. 不会立刻执行
2. 是个闭包函数
3. 执行前需要进行类型判断
4. 不能使用 `try catch` 捕获错误，不能直接return
4. 会导致回调地狱
        
    假设多个请求之间存在依赖性便会产生嵌套函数，一旦有所改动，牵一发而动全身，嵌套函数越多越难看还很难处理错误
### **Generator**
Generator函数可以在执行过程中多次返回，像是一个可以记住执行状态的函数，使用 `function*` 定义。使用Generator函数有个巨大的好处是，可以让嵌套函数以“同步”的方式写出来，并可以很好的使用 `try catch` 捕获错误。需要注意的是：
1. 每次next调用对应函数内部的yield方法
2. 调用next时传入的参数等于上一个yield的返回值，如果没有传参，yield永远返回undefined
### **Promise**
Promise翻译过来是承诺的意思，这个承诺会在未来有一个确切的答复，并且该承诺有三种状态：等待中（padding）、完成了（resolve）、拒绝了（reject）。

`Promise` 构造函数内的代码段会立即执行，状态改变后不能再次改变。`Promise` 实现了链式调用，每次调用then都会返回的都是一个全新的`Promise`，在`then`中使用`return`会被`Promise.resolve()`包装。
### **Async和Await**
一个函数前加上`async`声明异步后，那么该函数就会返回一个`Promise`，而`await`用于等待一个异步方法执行完成。`await`只能配合`async`使用，相比与`Promise`其优势在于处理`then`的调用链。`async`将函数内部的`return`返回值使用`Promise.resolve()`包装处理，和`then`中处理的一样。

- `await`的内部实现了`Generator`，会保留堆栈中的东西
- 异步执行，同步代码执行完成完毕后才开始执行
- `await`其实就是`Generator`加上`Promise`的语法糖，在`await`内部实现了自动执行`Generator`。
### **常用定时器函数**
setTimeOut、setInterval、requestAnimationFrame

setTimeOut不能单纯的理解为多久后执行一次，js是单线程执行的，如果前面的代码影响到性能了，并不会就在设置的时间之后执行。

setInterval，函数每隔一段时间执行一次回调函数。


## 深浅拷贝
对象类型在赋值过程中其实是复制了对象的内存地址，从而会导致改变了一方其他也会改变的情况。为了避免这种情况，可以通过浅拷贝来解决这个问题。
### **浅拷贝**
实现浅拷贝的方法：
1. `Object.assign`，拷贝所有属性到新的对象中，如果属性值是对象的话，将拷贝的是地址
2. `...`展开运算符
3. 针对数组的浅拷贝，还可以使用 `concat` 和 `slice` 方法

> 浅拷贝只能解决第一层的问题，如果第一层中有的属性值是对象的话，拷贝的还是地址，所以要彻底解决这个问题需要使用 **深拷贝** 。
### **深拷贝**
实现深拷贝，通常使用 `JSON.parse(JSON.stringify())` 方法序列化对象简单粗暴的办法，但是遇到 `undefined` ，`symbol` 类型的数据就不能正常拷贝了。而且不能序列化函数，不能解决循环引用的对象。

遇到上述的问题还是需要动手自己实现个深拷贝函数，在拷贝的时候判断一下属性值的类型，如果是对象我们就递归调用深拷贝函数。