JavaScript是一门`单线程`、`非阻塞`的脚本语言。单线程说的是，在JavaScript运行过程中，有且只有一个主线程来顺序执行所有的任务。

`为什么是单线程？`：为了和浏览器很好的进行交互，假设有多个线程同时操作一个dom元素，我到底是该执行删除操作还是添加操作？为了避免这样复杂且矛盾的操作，JavaScript自设计之初就选择只有一个主线程来执行代码，以此来保证程序执行的一致性。

`非阻塞又是怎么回事？`：非阻塞说的是线程运行到这里并不能当下立即获得结果，但是线程却不会因此而阻塞进行不下去。`JavaScript非阻塞是怎么实现的？`：通过事件循环机制（Event Loop），事件循环是让JavaScript做到既是单线程，又绝对不会阻塞的核心机制。

## Event Loop
首先需要熟悉两个概念`执行栈`、`事件队列`。

`执行栈`：当我们调用一个方法时，js会生成一个与方法对应的执行环境，也就是执行上下文，这个执行环境中包含了方法运行需要的参数，this对象、私有作用域等。每次调用函数都会创建一个新的执行上下文，执行栈就是用来管理这些上下文，可以把它认为是一个存储函数调用的栈结构，遵循先进后出的原则。

![栈：先进后出](https://segmentfault.com/img/remote/1460000018550122?w=486&h=238)

`事件队列`：所有的同步任务都是在主线程上执行，形成一个执行栈，而异步任务比如调起ajax，不会当下获得结果执行完毕，主线程会把这个异步任务挂起（pending），继续执行执行栈中的同步任务，当异步任务执行返回结果以后，会在事件队列中放置一个事件，待主线程上的同步任务执行完成之后，js就会来读取事件队列里面的事件，开始执行。这个过程是循环往复的，这个过程被称为Event Loop事件循环

![事件循环](https://pic2.zhimg.com/v2-251a5467555638c710eca5b2aa17839d_b.webp)

`异步任务回调执行的顺序，与js执行栈清空完成时间及其设置的延迟时间有关。`

在事件列表中，异步任务之间执行优先级也有不同，分为两类：

- 宏任务：定时器（setTimeOut、setInterval等）、I/O磁盘读写、ajax
- 微任务：process.nextTick()、Promise.then()

前面说到事件循环会将异步任务按照结果返回排列到事件队列中去，然而根据异步任务的分类不同，事件会被分配到对应的宏任务队列和微任务队列中去。

当执行栈中的同步任务执行完毕后，主线程会检查微任务队列中是否有任务，如果有就将微任务队列中的任务依次执行，直到微任务队列为空，再去检查宏任务队列中的任务，如果有则每次取出第一个宏任务加入到执行栈中执行，之后再清空执行栈，检查微任务队列，以此循环...

`同一次事件循环中，微任务永远比宏任务先执行。`

<details>
    <summary>click me</summary>
    <pre>
        <code>
            console.log(1); 
            setTimeout(() => {
                console.log('setTimeout');
            }, 0);
            let promise = new Promise(resolve => {
                console.log(3);
                resolve();
            }).then(data => {
                console.log(100);
            }).then(data => {
                console.log(200);
            });
            console.log(2);
            // 1 3 100 200 setTimeout
        </code>
    </pre>
</details>

 ![sss](https://pic3.zhimg.com/v2-01ab036dd9c2b0aa3a2b41a2b451ad16_b.webp)
