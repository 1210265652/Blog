## 面向对象的三大特性：封装、继承、多态

**封装**就是使用对象来封装变量和函数，可复用降低冗余度，更利于模块化编程，能够为变量函数提供更多的保护。

        function Person(name, age) {
            this.name = name //公开变量
            let ages = age // 私有变量
            this.showName = function () { // 公开函数
                console.log('this.name =', name)
            }
            function showAge() { // 私有函数
                console.log('this.age =', age, ages)
            }
        }

        let p = new Person('zyl', '26')
        p.showName() // this.name = zyl
        p.showAge() //  p.showAge is not a function

构造函数方式与原型方式给对象添加方法的区别：

        // 1. 通过构造函数方式给对象添加方法
        function Dog(name) {
            this.name = name
            this.shout = function() {
                console.log(this.name + '在尖叫！')
            }
        }

        let dog1 = new Dog('usa')
        let dog2 = new Dog('us')
        if (dog1.shout === dog2.shout) console.log('相等')
        else console.log('不相等')
        // 不相等

        // 2. 通过原型方式给对象添加方法
        Dog.prototype.shouts = function() {
            console.log(this.name + '在尖叫！')
        }
        let dog3 = new Dog('usa')
        let dog4 = new Dog('us')
        if (dog3.shouts === dog4.shouts) console.log('相等')
        else console.log('不相等')
        // 相等

需要注意的是，通过构造函数方式来分配成员，给每个对象分配一份独立的代码。这样的弊端在于如果对象实例很有很多，那函数的资源占用就会很大，而且有可能造成内存泄漏。

而原型方式则是大家共享同一份代码，就不会有这样的弊端。如果希望所有的对象使用同一个函数，最好使用原型函数添加方法，这样比较节省内存。

---

**多态**则是对于同一个对象在不同情况下的多种状态。可以理解成通过指向父类的引用，来调用在不同子类中实现的方法。利于代码的维护扩展，当我们需要使用同一类树上的对象时，只需要传入不同的参数就行了，而不需要再new一个对象。

        function Master(name) {
            this.name = name
        }
        Master.prototype.feed = function (animal, food) {
            console.log('给' + animal.name + '喂' + food.name)
        }
        function Cat(name) {
            this.name = name
        }
        function Fish(name) {
            this.name = name
        }
        function Tirger(name) {
            this.name = name
        }
        function Chicken(name) {
            this.name = name
        }
        let cat = new Cat('猫')
        let fish = new Fish('鱼')
        let tirger = new Tirger('老虎')
        let chicken = new Chicken('鸡肉')

        let master = new Master('zl')
        master.feed(cat, fish)
        master.feed(tirger, chicken)

--- 
**继承** 当多个类存在相同的属性（变量）和方法时，可以从这些类中抽象出父类，在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些相同的属性和方法，只需要通过继承父类中的属性和方法。

实现继承的方法：
- 类继承
- 原型继承
- 混合继承（构造+原型）
- 复制继承

**类继承**又分两种实现方式：
1. 对象冒充，将需要继承的对象赋值给对象属性

        // 1. 把子类中共有的属性和方法抽取出来，定义父类student
        function Student (name, age) {
            this.name = name
            this.age = age
            this.show = function() {
                console.log('------------')
                console.log('学生' + this.name + '今年' + this.age + '岁了！')
            }
        }
        function MidStu(name, age) {
            this.stu = Student // 通过对象冒充来实现继承 获取到需要继承类的所有成员，因为js是谁调用那个成员就是谁的，这样MidStu就有了Student的属性和方法了
            this.stu(name, age)
            this.payFee = function () {
                console.log('缴费 ', money)
            }
        }
        function Pupil(name, age) {
            this.stu = Student
            this.stu(name, age)
            this.payFee = function () {
                console.log('** 缴费 ', money)
            }
        }
        let midStu = new MidStu('zyl', '25')
        midStu.show() // 学生zyl今年25岁了！
        let pupil = new Pupil('zn', '27')
        pupil.show() // 学生zn今年27岁了！

2. 通过call和apply实现，通过call/apply方法修改了this指向，让它指向了调用者本身

        function MidStu1(name, age) {
            Student.call(this, name, age)
        }
        function Pupil1(name, age) {
            Student.apply(this, [name, age])
        }
        let midStu1 = new MidStu1('zyx', '23')
        midStu1.show() // 学生zyx今年23岁了！
        let pupil1 = new Pupil1('wzm', '2')
        pupil1.show() // 学生wzm今年2岁了！

    call和apply相关可查看[JavaScirpt之bind、call和apply的模拟实现](https://github.com/zzyundragon/Blog/issues/3)    


