# 函数表达式
- 函数表达式的特征
- 使用函数实现递归
- 使用闭包定义私有变量

创建函数有两种方式：1. 函数声明；2.函数表达式

函数声明有个特性，就是函数声明提升，在执行代码之前会先读取函数声明。
<details>
    <summary>show me code</summary>
    <pre>
        <code>
            console.log(test()) // say hi
            function test() {
                console.log('say hi')
            }
        </code>
    </pre>
</details>

而函数表达式则不可以，比如创建一个匿名函数将其赋值给变量，在创建赋值前调用则会报错。函数表达式相比于函数声明，可以很好地根据不同情况来创建函数。能够创建函数在赋值给变量，也可以把函数作为其他函数的返回值返回。
<details>
    <summary>show me code</summary>
    <pre>
        <code>
            console.log(test()) // error 函数不存在
            let test = function() {
                console.log('say hi')
            }
        </code>
    </pre>
</details>

## 递归
递归函数是在一个函数通过名字调用自身的情况下构成的，通俗来讲就是自己调用自己的函数。
<details>
    <summary>show me code</summary>
    <pre>
        <code>
           // 经典应用阶乘
           function factorial(num) {
               if (num <= 1) {
                   return 1
               } else {
                   return num * factorial(num - 1)
               }   
           }
        </code>
    </pre>
</details>

使用递归函数要注意两个问题：
1. 如果将递归函数保存在一个变量里，然后将递归函数置为空值，此时调用变量时会报错。递归函数内部调用自己是通过函数名调用的，就会找不到这个函数。
<details>
    <summary>show me code</summary>
    <pre>
        <code>
           let createFactorial = factorial
           factorial = null
           createFactorial(3) // factorial is not a function
        </code>
    </pre>
</details>

这种情况可以使用 `arguments.callee` 来解决
<details>
    <summary>show me code</summary>
    <pre>
        <code>
           // 经典应用阶乘
           function factorial(num) {
               if (num <= 1) {
                   return 1
               } else {
                   return num * arguments.callee(num - 1)
               }   
           }
        </code>
    </pre>
</details>

2. 在严格模式下不能通过脚本访问 `arguments.callee`，不过可以使用命名函数表达式来达到相同的效果
<details>
    <summary>show me code</summary>
    <pre>
        <code>
           // 创建一个名为 f() 的命名函数表达式，然后赋值给变量
           let factorial = (function f(num) {
               if (num <= 1) {
                   return 1
               } else {
                   return num * f(num - 1)
               }   
           })
        </code>
    </pre>
</details>

## 闭包
闭包是指能够访问另一个函数作用域中变量的函数。常见的创建方式是，在一个函数内部创建另一个函数。

闭包函数之所以能够访问另一个函数作用域中的变量，是因为内部函数的作用域链中包含了外部函数的作用域。

要彻底搞清楚其中的细节，必须先理解有关如何创建作用域链以及作用域链有什么作用的细节。

### 执行环境及作用域
