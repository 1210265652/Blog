# 函数表达式
- 函数表达式的特征
- 使用函数实现递归
- 使用闭包定义私有变量

创建函数有两种方式：1. 函数声明；2.函数表达式

函数声明有个特性，就是函数声明提升，在执行代码之前会先读取函数声明。
<details>
    <summary>show me code</summary>
    <pre>
        <code>
            console.log(test()) // say hi
            function test() {
                console.log('say hi')
            }
        </code>
    </pre>
</details>

而函数表达式则不可以，比如创建一个匿名函数将其赋值给变量，在创建赋值前调用则会报错。函数表达式相比于函数声明，可以很好地根据不同情况来创建函数。能够创建函数在赋值给变量，也可以把函数作为其他函数的返回值返回。
<details>
    <summary>show me code</summary>
    <pre>
        <code>
            console.log(test()) // error 函数不存在
            let test = function() {
                console.log('say hi')
            }
        </code>
    </pre>
</details>

## 递归
递归函数是在一个函数通过名字调用自身的情况下构成的，通俗来讲就是自己调用自己的函数。
<details>
    <summary>show me code</summary>
    <pre>
        <code>
           // 经典应用阶乘
           function factorial(num) {
               if (num <= 1) {
                   return 1
               } else {
                   return num * factorial(num - 1)
               }   
           }
        </code>
    </pre>
</details>

使用递归函数要注意两个问题：
1. 如果将递归函数保存在一个变量里，然后将递归函数置为空值，此时调用变量时会报错。递归函数内部调用自己是通过函数名调用的，就会找不到这个函数。
<details>
    <summary>show me code</summary>
    <pre>
        <code>
           let createFactorial = factorial
           factorial = null
           createFactorial(3) // factorial is not a function
        </code>
    </pre>
</details>

这种情况可以使用 `arguments.callee` 来解决
<details>
    <summary>show me code</summary>
    <pre>
        <code>
           // 经典应用阶乘
           function factorial(num) {
               if (num <= 1) {
                   return 1
               } else {
                   return num * arguments.callee(num - 1)
               }   
           }
        </code>
    </pre>
</details>

2. 在严格模式下不能通过脚本访问 `arguments.callee`，不过可以使用命名函数表达式来达到相同的效果
<details>
    <summary>show me code</summary>
    <pre>
        <code>
           // 创建一个名为 f() 的命名函数表达式，然后赋值给变量
           let factorial = (function f(num) {
               if (num <= 1) {
                   return 1
               } else {
                   return num * f(num - 1)
               }   
           })
        </code>
    </pre>
</details>

## 闭包
闭包是指能够访问另一个函数作用域中变量的函数。常见的创建方式是，在一个函数内部创建另一个函数。

闭包函数之所以能够访问另一个函数作用域中的变量，是因为内部函数的作用域链中包含了外部函数的作用域。

要彻底搞清楚其中的细节，必须先理解有关如何创建作用域链以及作用域链有什么作用的细节。

### 执行环境及作用域

`执行环境` 定义了变量或函数有权访问的其他数据，决定了它们的行为。

每个执行环境都有个与之关联的 `变量对象` ，里面保存着环境中定义的变量和函数。

`全局执行环境` 是最外围的一个执行环境，根据所在宿主环境的不同，表示执行环境的对象也不一样。在web浏览器中，全局执行环境被认为是window对象，因此全局变量和函数都是作为window对象的属性和方法来创建的。

`执行环境是有生命周期的`，当某个执行环境中的所有代码都执行完毕了，该环境会被销毁，保存在其中的变量和函数也随之销毁。全局执行环境只有在应用程序退出后销毁。

当代码在一个环境中执行，会创建变量对象的 `作用域链`。作用域链保证了对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在环境的变量对象，如果这个执行环境是函数，则将其 `活动对象` 作为变量对象。

活动对象在最开始时，只包含一个变量就是 `arguments` 对象。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样一直延续到全局执行环境。全局执行环境的变量对象始终是作用域链中的最后一个对象。